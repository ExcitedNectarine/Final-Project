[VERTEX]
attribute vec3 in_position;
attribute vec4 in_uv;
attribute vec3 in_normal;
attribute vec3 in_tangent;
attribute vec3 in_bitangent;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 transform;

varying vec3 out_uv;
varying vec3 out_normal;
varying vec3 out_frag_pos;
varying mat3 out_tbn;

void main()
{
	out_uv = in_uv;
	out_frag_pos = vec3(transform * vec4(in_position, 1.0));

	mat3 inv_t = mat3(transpose(inverse(transform)));
	out_normal = inv_t * in_normal;
	vec3 t = normalize(vec3(transform * vec4(inv_t * in_tangent, 0.0)));
	vec3 b = normalize(vec3(transform * vec4(inv_t * in_bitangent, 0.0)));
	vec3 n = normalize(vec3(transform * vec4(inv_t * in_normal, 0.0)));	
	out_tbn = transpose(mat3(t, n, b));
	
	gl_Position = projection * view * vec4(out_frag_pos, 1.0);
}

[FRAGMENT]
uniform sampler2D texture;
uniform sampler2D normal;

varying vec3 out_uv;
varying vec3 out_normal;
varying vec3 out_frag_pos;
varying mat3 out_tbn;

uniform vec3 ambient;
uniform vec3 view_pos;

#define MAX_LIGHTS 128
#define CONSTANT 1.0
#define LINEAR 0.7
#define QUADRATIC 1.8

struct Light
{
	vec3 position;
	vec3 colour;
	float radius;
};

uniform Light lights[MAX_LIGHTS];

void main()
{
	float distance;
	float attenuation;
	vec3 diffuse;
	vec3 specular;
	vec3 total_light = ambient;
	vec4 tex = texture2D(texture, out_uv);
	vec3 t_norm = texture2D(normal, out_uv).rgb;
	
	for (int i = 0; i < MAX_LIGHTS; i++)
	{	
		// Calculate diffuse
		//vec3 norm = normalize(out_tbn * (t_norm * 2.0 - 1.0));
		vec3 norm = normalize(out_normal);
		vec3 light_dir = normalize(lights[i].position - out_frag_pos);
		float diff = max(dot(norm, light_dir), 0.0);
		diffuse = diff * vec3(tex) * lights[i].colour;
		
		// Calculate specular
		vec3 view_dir = normalize(view_pos - out_frag_pos);
		vec3 reflect_dir = normalize(-light_dir - norm);
		float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32);
		specular = 0.5 * spec * lights[i].colour;
		
		distance = length(lights[i].position - out_frag_pos);
		//attenuation = 1.0 / (CONSTANT + LINEAR * distance + QUADRATIC * (distance * distance));
		attenuation = clamp(lights[i].radius / distance, 0.0, 1.0);
		
		diffuse *= attenuation;
		specular *= attenuation;
		
		total_light += diffuse;// + specular;
	}
	
	gl_FragColor = tex * vec4(total_light, 1.0);
}